#!/usr/bin/env python

import os
import sys
import subprocess
from datetime import datetime
import time
import signal
import configparser
import argparse
import RPi.GPIO as GPIO
from threading import Timer, Event, Thread

DAEMONIZE = False

PIDFILE = "/var/run/cleanshutdownd.pid"
LOGFILE = "/var/run/cleanshutdownd.log"
ERRFILE = "/var/run/cleanshutdownd.err"

CONFIG_FILE = "/etc/cleanshutdownd.conf"

# Set if button is pressed long enough to trigger a reboot
pending_reboot = False

reboot_timer = None
shutdown_timer = None
flashled_thread = None

class FlashLED(Thread):
    def __init__(self, led_pin, shutdown_hold_time):
        Thread.__init__(self)
        self.stopped = Event()
        self.shutdown_hold_time = shutdown_hold_time
        self.led_pin = led_pin

    def stop(self):
        self.stopped.set()

    def _blink_speed(self, start_time):
        t_elapsed = (time.time() - start_time) / float(self.shutdown_hold_time)
        t_wait = 0.5 - (0.5 * t_elapsed)
        return t_wait

    def run(self):
        started = time.time()
        GPIO.output(self.led_pin, GPIO.HIGH)
        while not self.stopped.wait(self._blink_speed(started)):
            state = not GPIO.input(self.led_pin)
            GPIO.output(self.led_pin, state)
            if self._blink_speed(started) <= 0:
                self.stop()
                break

        GPIO.output(self.led_pin, GPIO.LOW)

def log(*args):
    sys.stdout.write(str(datetime.now()))
    sys.stdout.write(":")
    for a in args:
        sys.stdout.write(" ")
        sys.stdout.write(str(a))

    sys.stdout.write("\n")
    sys.stdout.flush()

def daemonize(pid_file=PIDFILE, log_file=LOGFILE, error_file=ERRFILE):
    try:
        pid = os.fork()
        if pid > 0:
            sys.exit(0)

    except OSError, e:
        log("Fork #1 failed: {} ({})".format(e.errno, e.strerror))
        sys.exit(1)

    os.chdir("/")
    os.setsid()
    os.umask(0)

    try:
        pid = os.fork()
        if pid > 0:
            fpid = open(pid_file, "w")
            fpid.write(str(pid))
            fpid.close()
            sys.exit(0)
    except OSError, e:
        log("Fork #2 failed: {} ({})".format(e.errno, e.strerror))
        sys.exit(1)

    stdin = file("/dev/null", "r")
    stdout = file(log_file, "a+", 0)
    stderr = file(error_file, "a+", 0)

    os.dup2(stdin.fileno(), sys.stdin.fileno())
    os.dup2(stdout.fileno(), sys.stdout.fileno())
    os.dup2(stderr.fileno(), sys.stderr.fileno())


class Config():
    def __init__(self, config_file, required_sections=None):
        self.config = configparser.ConfigParser()
        self.config.read(config_file)

        if required_sections is not None:
            for section in required_sections:
                if not self.has_section(section):
                    raise RuntimeError("Missing \"{}\" config section.".format(section))

    def has_section(self, section):
        return section in self.config.sections()

    def get(self, section, option, datatype=str, valid_values=None, default=None):
        value = self.config.get(section, option, fallback=default)

        value = value.decode()

        if value.lower() in ["none", "off"]:
            value = None

        log(section, option, value, default)

        if datatype is bool:
            if value.lower() in ["true", "1", "yes"]:
                value = True
            elif value.lower() in ["false", "0", "no"]:
                value = False
            else:
                value = default
        else:
            try:
                value = datatype(value)
            except (ValueError, TypeError), e:
                print(e)
                value = default

        if datatype is str and len(value) == 0:
            value = default

        if isinstance(valid_values, list) and value not in valid_values:
            value = default

        return value


def main():
    if DAEMONIZE:
        daemonize()

    config = Config(CONFIG_FILE, required_sections=["General", "Switch", "Timings", "Hooks", "Files"])

    opt_enabled = config.get("General", "enabled", datatype=bool, default=False)
    opt_poweroff_pin = config.get("General", "poweroff_pin", datatype=int, default=None)
    opt_status_led_pin = config.get("General", "status_led_pin", datatype=int, default=None)

    opt_switch_pin = config.get("Switch", "pin", datatype=int, default=None)
    opt_switch_type = config.get("Switch", "type", datatype=str, valid_values=["momentary", "toggle"], default="momentary")
    opt_switch_polarity = config.get("Switch", "polarity", datatype=str, valid_values=["low", "high"], default="low")

    opt_timings_reboot = config.get("Timings", "reboot_hold", datatype=int, default=None)
    opt_timings_shutdown = config.get("Timings", "shutdown_hold", datatype=int, default=3)
    opt_timings_delay = config.get("Timings", "shutdown_delay", datatype=int, default=0)

    opt_files_pid = config.get("Files", "pid_file", datatype=str, default=PIDFILE)
    opt_files_err = config.get("Files", "error_file", datatype=str, default=ERRFILE)
    opt_files_log = config.get("Files", "log_file", datatype=str, default=LOGFILE)

    opt_hook_reboot = config.get("Hooks", "before_reboot", datatype=str, default=None)
    opt_hook_shutdown = config.get("Hooks", "before_shutdown", datatype=str, default=None)

    log("""
    General:
        Enabled: {opt_enabled}
        Status LED: {opt_status_led_pin}
        Poweroff Pin: {opt_poweroff_pin}

    Switch:
        Pin: {opt_switch_pin}
        Type: {opt_switch_type}
        Polarity: {opt_switch_polarity}


    Timings:
        Reboot: {opt_timings_reboot}
        Shutdown: {opt_timings_shutdown}
        Delay: {opt_timings_delay}

    Hooks:
        Reboot Hook:
        Shutdown Hook:

    Files:
        Error: {opt_files_err}
        Log: {opt_files_log}
        PID: {opt_files_pid}

    """.format(**locals()))

    GPIO.setmode(GPIO.BCM)
    GPIO.setwarnings(False)

    if opt_status_led_pin is not None and opt_status_led_pin is not opt_switch_pin:
        GPIO.setup(opt_status_led_pin, GPIO.OUT, initial=GPIO.LOW)

    GPIO.setup(opt_switch_pin, GPIO.IN, pull_up_down=GPIO.PUD_UP if opt_switch_polarity == "low" else GPIO.PUD_DOWN)

    def do_shutdown():
        global pending_reboot
        pending_reboot = False
        log("Shutdown Triggered")
        if opt_hook_shutdown is not None:
            try:
                subprocess.check_call(opt_hook_shutdown)
            except subprocess.CalledProcessError, e:
                log("ABORTING SHUTDOWN: {}".format(e))
                return
        
    def do_reboot():
        global pending_reboot
        pending_reboot = False
        log("Reboot Triggered")
        if opt_hook_reboot is not None:
            try:
                subprocess.check_call(opt_hook_reboot)
            except subprocess.CalledProcessError, e:
                log("ABORTING REBOOT: {}".format(e))
                return

    def set_reboot():
        global pending_reboot
        #log("Reboot Queued")
        pending_reboot = True

    def switch_trigger(pin):
        global shutdown_timer, reboot_timer, flashled_thread

        #log("SWITCH_TRIGGER: Caught {} edge on pin {}".format(pin, opt_switch_polarity))

        GPIO.remove_event_detect(opt_switch_pin)
        GPIO.add_event_detect(opt_switch_pin, GPIO.RISING if opt_switch_polarity == "low" else GPIO.FALLING, callback=switch_clear)
        shutdown_timer = Timer(opt_timings_shutdown, do_shutdown)
        shutdown_timer.start()


        if opt_status_led_pin is not None and opt_status_led_pin is not opt_switch_pin:
            log("Flashing status LED")
            flashled_thread = FlashLED(opt_status_led_pin, opt_timings_shutdown)
            flashled_thread.start()

        if opt_timings_reboot > 0:
            reboot_timer = Timer(opt_timings_reboot, set_reboot)
            reboot_timer.start()

    def switch_clear(pin):
        global shutdown_timer, reboot_timer, flashled_thread

        #log("SWITCH_CLEAR: Caught {} edge on pin {}".format(pin, opt_switch_polarity))

        try:
            flashled_thread.stop()
            flashled_thread =  None
        except AttributeError, e:
            pass

        try:
            shutdown_timer.cancel()
            shutdown_timer = None
        except AttributeError, e:
            pass

        try:
            reboot_timer.cancel()
            reboot_timer = None
        except AttributeError, e:
            pass

        if pending_reboot:
            do_reboot()

        GPIO.remove_event_detect(opt_switch_pin)
        GPIO.add_event_detect(opt_switch_pin, GPIO.FALLING if opt_switch_polarity == "low" else GPIO.RISING, callback=switch_trigger)

    switch_clear(None)

    signal.pause()

if __name__ == "__main__":
    main()
